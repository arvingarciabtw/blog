I'm now currently on the [Node.js course](https://www.theodinproject.com/paths/full-stack-javascript/courses/nodejs) of The Odin Project curriculum. I've progressed farther than I've expected this week. I'm currently doing the file uploader project, which involves using the [Prisma ORM](https://www.prisma.io/). But, to keep this article short and simple, I'll just simply talk about Node.js!

From the actual [Node.js website](https://nodejs.org/en/about/):

> "As an asynchronous event-driven JavaScript runtime, Node.js is designed to build scalable network applications."

Node.js is a JavaScript runtime that allows us to write JavaScript code outside of the browser. So, it allows us to write server-side code in JavaScript. Node.js lets us read and write local files, create HTTP connections, and listen to network requests.

Going back to its definition, it's a runtime that is asynchronous and event-driven. This is where callbacks become crucial to understanding how Node.js works.

Callbacks are fundamental to Node.js's asynchronous nature. A callback is simply a function that gets passed as an argument to another function and is executed after some operation completes. Instead of waiting for time-consuming operations like file reads or database queries to finish, Node.js continues executing other code and calls your callback function when the operation is done.

For example, when reading a file, you don't want your entire server to freeze while waiting for the file system. With callbacks, Node.js can handle other requests while the file is being read, then execute your callback once the data is ready:

```js
const fs = require('fs');

fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }
  console.log('File contents:', data);
});

console.log('This runs immediately, without waiting!');
```

This callback pattern is what makes Node.js so efficient for I/O-heavy applications. It can handle thousands of concurrent connections without creating a new thread for each one. While modern Node.js also supports `Promises` and `async/await` syntax, understanding callbacks is essential since they're the foundation of Node.js's event-driven architecture.

The event-driven model means Node.js applications respond to events like incoming HTTP requests, file operations completing, or timers expiring by executing the appropriate callback functions. This design philosophy is what allows Node.js to be so scalable and performant for real-time applications.

With all of that said, let's write a simple Hello World script and execute it with Node.js! In an `app.js`, write:

```js
console.log('Hello, World!');
```

Then, simply run this in your terminal, and it should work:

```bash
node app.js
```

I'll talk about [Express](https://expressjs.com/) in the article next week!
