This week, I've completed the [React](https://www.theodinproject.com/paths/full-stack-javascript/courses/react) course from The Odin Project! The final project for this one is developing a single page application that utilizes React Router for client-side routing. So, I'll go over what I've learned while doing this project.

First, let's talk about the difference of a single page application (SPA) from a multi-page application (MPA). A SPA is a web application that loads and updates content dynamically. So, every time we navigate through different pages in our app, the page doesn't need to reload!

However, for a MPA, the page would have to reload when we navigate through different sections. But, MPAs do have some advantages over SPAs, like [better SEO](https://medium.com/@sehban.alam/single-page-applications-spas-vs-multi-page-applications-mpas-advantages-and-challenges-df06bee3fed1). As of writing, I actually refactored this blog of mine to a single page React application! I used to simply have different HTML files for each blog article.

So, where does client-side routing actually come into all of this? Well, it's what will help us in creating our SPA! Client-side routing is a type of routing where navigation between different pages of a web application is managed by the browser using JavaScript.

Client-side routing does come with some caveats. For example, you'd need to notify screen-readers of route updates manually. Thankfully, we can use a routing library for React applications like [React Router](https://reactrouter.com/) to help us with our concerns!

Let's take a look at some code from a [lesson](https://www.theodinproject.com/lessons/node-path-react-new-react-router) in The Odin Project:
```javascript
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { createBrowserRouter, RouterProvider } from "react-router";
import App from "./App";
import Profile from "./Profile";

const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
  },
  {
    path: "profile",
    element: <Profile />,
  },
]);

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <RouterProvider router={router} />
  </StrictMode>
);
```

The `createBrowserRouter` and `RouterProvider` are the important stuff to take note of here. `createBrowserRouter` simply creates our router configuration. Its configuration will be based on the arguments passed into it, which will be an array of routes, represented as objects.

Each route has a `path` and `element` property. In the `path` property, the value should be its path (what a surprise!) in the URL. Then, in the `element` property, its value should be the component you want to render when the user navigates to the path you specified prior.

However, to make sure the browser does *not* reload the page whenever we navigate through our application, we *must* use `Link`, a custom element from React Router, instead of a regular `a` tag. It would look something like this:
```javascript
import { Link } from "react-router";

const App = () => {
  return (
    <div>
      <h1>Hello from the main page of the app!</h1>
      <p>Here are some examples of links to other pages</p>
      <nav>
        <ul>
          <li>
            <Link to="profile">Profile page</Link>
          </li>
        </ul>
      </nav>
    </div>
  );
};

export default App;
```

React Router has another useful custom element called `Outlet`. An `Outlet` basically lets us render a child route of a parent route. But, what's a child route? Let's take a look at an example, taken from the source code of this blog!
```javascript
// These are my routes, located in another file
const routes = [
  {
    path: '/',
    element: <App />,
    errorElement: <ErrorPage />,
    children: [
      { index: true, element: <HomePage /> },
      { path: '/:url', element: <ArticlePage /> },
    ],
  },
];

// App.jsx
import { Outlet } from 'react-router';

function App() {
  return (
    <>
      <Outlet />
    </>
  );
}
```

So, in our route, we introduced a new property called `children`. This property has an array of routes inside it. By default, it will render a `HomePage` component. However, if our URL changes (in this case, the user clicks on a blog article in the home page), then the `Outlet` will now render the `ArticlePage` component. Pretty cool!

And while we're on the topic of `Outlet`, it might be worth checking out `useOutletContext`. You can pass any value into the `context` prop of an `Outlet`, and then you can retrieve this value inside any child component using the `useOutletContext` hook.

You might notice as well that one of the child routes in our code above points to a path `/:url`.

`:` turns the path section after it into a "dynamic segment". Dynamic segments will match dynamic values in that URL's position. These are called `params`, which can be used with the help of the `useParams` hook. If you check out some of my other articles, you can see that their paths are dynamic!

And that's about it! I also learned some other stuff while doing the project like testing with [Vitest](https://vitest.dev/) and styling components with [CSS modules](https://github.com/css-modules/css-modules). But, I wanted to focus on client-side routing for this article. Feel free to check out the [live preview](https://nexus-tech-shop.vercel.app/) and the [source code](https://github.com/arvingarciabtw/the-odin-project/tree/main/full-stack-javascript/fsj-04-react/23-shopping-cart) of my project!

I'm now on the databases course of The Odin Project, so I'll talk about that next week!
